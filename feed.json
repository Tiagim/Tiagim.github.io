{
    "version": "https://jsonfeed.org/version/1",
    "title": "重樱的长门",
    "subtitle": "",
    "icon": "https://tiagim.github.io/assets/favicon.ico",
    "description": "汝是打算邀请吾出去玩吗？",
    "home_page_url": "https://tiagim.github.io",
    "items": [
        {
            "id": "https://tiagim.github.io/OI/slope/",
            "url": "https://tiagim.github.io/OI/slope/",
            "title": "浅谈斜率优化",
            "date_published": "2023-03-26T09:35:52.000Z",
            "content_html": "<p>之前研究过一段时间的斜率优化，总觉的什么时候该写写。</p>\n<span id=\"more\"></span>\n<hr>\n<h1 id=\"普通斜优\"><a href=\"#普通斜优\" class=\"headerlink\" title=\"普通斜优\"></a>普通斜优</h1><p>斜率优化是一种优化DP的方法，主要应用于 $1D&#x2F;1D$ 的转移中（也有反例），一般可以把复杂度优化成 $O(n)$ 或 $O(n\\log n)$。斜率优化主要利用了++单调性++{.wavy}，所以在阅读下文之前，请至少熟练掌握++单调队列++{.wavy}。</p>\n<p>本文以下面这道题为例讲解斜率优化，并对涉及到的一些本题之外的问题，在后文提供练习题。</p>\n<p>+++ [HNOI2008]玩具装箱</p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h2><p>有 $n$ 个玩具，第 $i$ 个长度为 $c_i$。将第 $i$ 到第 $j$ 个玩具装到一个箱子里会花费 $(j-i+\\sum\\limits_{k&#x3D;i}^jc_k-L)^2$ 的代价。求总代价最小值。</p>\n<p>$1\\leqslant n\\leqslant 5\\times 10^4$，$1\\leqslant L,c_i\\leqslant 10^7$</p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h2><p>第一行两个整数，$n$ 和 $L$。</p>\n<p>第 $2$ 到第 $(n+1)$ 行，第 $(i+1)$ 行一个整数 $c_i$。</p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h2><p>一行一个整数代表最小总代价。</p>\n<h2 id=\"样例\"><a href=\"#样例\" class=\"headerlink\" title=\"样例\"></a>样例</h2><pre><code class=\"language-raw\">5 4\n3\n4\n2\n1\n4\n</code></pre>\n<pre><code class=\"language-raw\">1\n</code></pre>\n<p>+++</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>设计DP。</p>\n<p>设 $f_i$ 表示第 $i$ 个玩具作为其所处的箱子的结尾的时候，前面所有箱子的总代价的最小值。记 $s_i$ 为 $c_i$ 的前缀和，得到 $n^2$ 状态转移方程：$f_i&#x3D;\\min\\limits_{1\\leqslant j\\leqslant i}\\big(f_j+(i-j+s_i-s_j-L-1)^2\\big)$。记 $w_i$ 为 $s_i+i$，得：$f_i&#x3D;\\min\\limits_{1\\leqslant j\\leqslant i}\\big(f_j+(w_i-w_j-L-1)^2\\big)$</p>\n<p>至于为什么后面要 $-1$？是因为实质上是第 $(j+1)$ 个到第 $i$ 个玩具装到一个箱子中所以是 $i-(j+1)&#x3D;i-j-1$ !!应该只有我一开始不知道吧!!。</p>\n<p>现在这个转移是 $n^2$ 的，显然会炸，考虑优化。</p>\n<h2 id=\"思考方式\"><a href=\"#思考方式\" class=\"headerlink\" title=\"思考方式\"></a>思考方式</h2><p>下面将以两种思维解释斜优的过程：数形结合和线性规划。</p>\n<p>;;;id1 数形结合</p>\n<p>先变化一下转移，变化的方法在后面给出，这样变化的好处也会体现。假设现在有两个决策点 $j,k$$(j&gt;k)$，而从 $j$ 转移到 $i$ 比从 $k$ 转移到 $i$ 优，即：</p>\n<p>$$<br>\\begin{aligned}<br>f_j+(w_i-w_j-L-1)^2&amp;\\leqslant f_k+(w_i-w_k-L-1)^2\\<br>f_j+(w_i-L-1)^2-2(w_i-L-1)w_j+w_j^2&amp;\\leqslant f_k+(w_i-L-1)^2-2(w_i-L-1)w_k+w_k^2\\<br>f_j-2(w_i-L-1)w_j+w_j^2&amp;\\leqslant f_k-2(w_i-L-1)w_k+w_k^2\\<br>f_j-f_k+w_j^2-w_k^2&amp;\\leqslant 2(w_i-L-1)(w_j-w_k)<br>\\end{aligned}<br>$$</p>\n<p>由于 $j&gt;k$ 且 $w_i$ 递增，所以 $w_j-w_k&gt;0$（可能会遇到等于 $0$ 的情况，需要特判为 $INF$），即：</p>\n<p>$$<br>\\begin{aligned}<br>\\frac {f_j+w_j^2-(f_k+w_k^2)}{w_j-w_k}&amp;\\leqslant 2(w_i-L-1)<br>\\end{aligned}<br>$$</p>\n<p>此处变化的原则是把++仅关于 $i$ 的项++{.dot}和++仅关于 $j$ 的项++{.dot}放在一边，把++关于 $i$ 且关于 $j$ 的项++{.dot}放在另一边，至于到底在那边并不重要，换边乘 $-1$ 就行了。</p>\n<p>变化完之后，我们发现如果记 $y_i&#x3D;f_i+w_i^2$，$x_i&#x3D;w_i$，那么式子左边就是 $\\frac{y_j-y_k}{x_j-x_k}$，形如一个直线的斜率。也就是说，如果把决策点按照 $(w_i,f_i+w_i^2)$ 为坐标的样子标记在平面直角坐标系上，那么如果决策点 $p_1$ 和决策点 $p_2$ $(x_{p_1}&gt;x_{p_2})$ 的连线的斜率 $\\leqslant 2(w_i-L-1)$ 那么决策点 $p1$ 优于决策点 $p2$。</p>\n<p>:::info<br>对于刚学斜优的同学，为避免麻烦的细节处理，可以把斜优模板化。比如此处建议尽量把最终的式子化为 $\\frac{y_j-y_k}{x_j-x_k}$ 的形式，而不是 $\\frac{y_k-y_j}{x_j-x_k}$。!!熟练掌握之后倒也无所谓!!<br>:::</p>\n<p>进一步的，我们假设有三个++候选决策点++{.wavy} $p_1,p_2,p_3$，他们在平面上形如这样：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/09/geogebra-export.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>他们满足条件：$k_1&gt;k_2$。记 $2(w_i-L-1)$ 为 $k_0$，那么接下来 $k_1,k_2$ 与 $k_0$ 的关系有以下几种：</p>\n<ol>\n<li>$k_0&lt;k_2&lt;k_1$，此时 $p_1$ 优于 $p_2$ 优于 $p_3$。</li>\n<li>$k_2\\leqslant k_0&lt;k_1$，此时 $p_1$ 优于 $p_2$ 且 $p_3$ 优于 $p_2$。</li>\n<li>$k_2&lt;k_1\\leqslant k_0$，此时 $p_3$ 优于 $p_2$ 优于 $p_1$。</li>\n</ol>\n<p>综上，在 $k_1&gt;k_2$ 的条件下，无论如何决策点 $p_2$ 一定是++不优的++{.wavy}，于是可以把从候选决策点中删除，像这样：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/10/geogebra-export.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>再把三个点扩展到平面上的很多点，对于任意三个点进行上述操作。在本题中，剩下的点++从左到右++{.dot}依次连线形成的直线的斜率++单调递增++{.wavy}。这样连线画图的结果就像一个++下凸包++{.wavy}。</p>\n<blockquote>\n<p>所有内角大小都在 $[0,\\pi]$ 范围内的简单多边形叫凸多边形。</p>\n<p>在平面上能包含所有给定点（即具有凸性）的最小凸多边形叫做凸包。</p>\n</blockquote>\n<p>下凸包就是凸包的下半部分。如图是维护的下凸包的例子：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/12/geogebra-export.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>在寻找决策点的过程中，我们一定能找到三个决策点 $p_1,p_2,p_3$ 满足 $k_{p_1,p_2}\\leqslant k_0&lt;k_{p_2,p_3}$。此时 $p_2$ 优于 $p_1$ 且优于 $p_3$，基于本题斜率单调递增的性质，其他直线要么 $k_p&lt;k_0$ 要么 $k_p&gt;k_0$，他们相应的决策点均不优于 $p_2$，那么我们称 $p_2$ 为++最优决策点++{.wavy}。</p>\n<p>在已经维护好的下凸包上，从前往后依次找到第一个斜率大于 $k_0$ 的线段，它的左端点就是最优决策点。由于维护好的凸包从左往右斜率单调，所以可以二分找到最优决策点。</p>\n<p>;;;</p>\n<p>;;;id1 线性规划</p>\n<p>忽略 $\\min$，把上面的式子变化成 $y&#x3D;kx+b$ 的形式，即：</p>\n<p>$$<br>\\begin{aligned}<br>f_i&amp;&#x3D;f_j+\\big((w_i-L-1)-w_j\\big)^2\\<br>&amp;&#x3D;f_j+(w_i-L-1)^2-2(w_i-L-1)w_j+w_j^2<br>\\end{aligned}\\<br>f_j+w_j^2&#x3D;2(w_i-L-1)w_j+f_i-(w_i-L-1)^2<br>$$</p>\n<p>此处变化的原则是：</p>\n<ol>\n<li>把 $g_i*g_j$ 看成 $kx$。</li>\n<li>$f_i$ 必须在 $b$。</li>\n<li>$y$ 只含 $g_j$，并++按需++{.dot}与 $kx$ 合并。</li>\n<li>如果 $kx$ 单减，建议两边同乘 $-1$ 使其单增。</li>\n</ol>\n<p>:::danger<br>注意，划分方式不止一种。<br>:::</p>\n<p>对于这种划分：</p>\n<ul>\n<li>$y$ 为 $f_j+w_j^2$</li>\n<li>$k$ 为 $2(w_i-L-1)$</li>\n<li>$x$ 为 $w_j$</li>\n<li>$b$ 为 $f_i-(w_i-L-1)^2$</li>\n</ul>\n<p>假如有一堆点在平面上长这样：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/20/geogebra-export-1.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>我们的目的是使 $f_i$ 最小，即使 $b&#x3D;f_i-(w_i-L-1)^2$ 最小，就是要求一个过一点的斜率为 $2(w_i-L-1)$ 直线使其截距最小，转为线性规划问题。</p>\n<p>那么最优决策点就很好找了：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/20/geogebra-export-2.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>图中 $F$ 即为最优决策点，且最优决策点必然处于凸包上。</p>\n<p>;;;</p>\n<p>即便有两种思路，但是建议结合使用：</p>\n<ul>\n<li>在思考前，主要利用代数法转换方程，确定斜率形式。</li>\n<li>在思考阶段建议多用线性规划思想，利用图形直观感受，更好得判断单调性（后文会讲）。</li>\n</ul>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>用单调队列 $q$ 维护凸包，开头为 $s$，结尾为 $t$，操作如下：</p>\n<ol>\n<li>在凸包上找到最优决策点 $j$。</li>\n<li>用 $j$ 更新 $i$。</li>\n<li>把 $i$ 作为下一个决策点加入平面，更新凸包</li>\n</ol>\n<p>对于操作3，比较 $q_{t-1}$、$q_t$ 和 $i$，看是否能删掉 $q_t$：能删就删，重复操作3；不能删就把 $i$ 加入队列。</p>\n<p>判断能否删点有两种方法（可以结合上文“数形结合”中的图理解）：</p>\n<ol>\n<li><code>slope(q[t],q[t-1])&gt;slope(q[t],i)</code></li>\n<li><code>slope(q[t],q[t-1])&gt;slope(q[t-1],i)</code></li>\n</ol>\n<p>两者是等价的，可把 <code>q[t]</code> 删除，读者自己思考。</p>\n<p>对于操作1，暴力找的话复杂度还是 $O(n^2)$，二分查找可使复杂度降为 $O(n\\log n)$。</p>\n<p>复杂度瓶颈在于操作1。</p>\n<h2 id=\"再优化\"><a href=\"#再优化\" class=\"headerlink\" title=\"再优化\"></a>再优化</h2><p>如果要继续降低复杂度的话，将要利用++决策单调性++{.wavy}，其简单定义为：</p>\n<blockquote>\n<p>对于形如 $f_i&#x3D;f_j+W(i,j)$的方程，即 $1D&#x2F;1D$ 转移方程，设 $t_i$ 表示 $f_i$ 的最优决策点。那么决策单调性可表示为 $\\forall j\\leqslant k,t_j\\leqslant t_k$。也就是说 $t_i$ 不降。</p>\n</blockquote>\n<p>证明见下。</p>\n<h3 id=\"四边形不等式\"><a href=\"#四边形不等式\" class=\"headerlink\" title=\"四边形不等式\"></a>四边形不等式</h3><p>设二元函数 $W(x,y)$ 定义域为整数。若 $\\forall a\\leqslant b\\leqslant c\\leqslant d,W(a,c)+W(b,d)\\leqslant W(a,d)+W(b,c)$，那么函数 $W(x,y)$ 满足++四边形不等式++{.wavy}。</p>\n<p>从形的角度来看，把 $W(x,y)$ 画成这样：</p>\n<p><img loading=\"lazy\" src=\"https://cdnjson.com/images/2023/03/21/geogebra-export-1.png\">{height&#x3D;”400px” width&#x3D;”400px”}</p>\n<p>那么满足左下角加右上角小于等于左上角加右下角的 $W(x,y)$ 满足四边形不等式。</p>\n<p>四边形不等式也可表示为 $\\forall a&lt;b,W(a,b)+W(a+1,b+1)\\leqslant W(a+1,b)+W(a,b+1)$，证明如下：</p>\n<p>$\\because\\forall a&lt;c,W(a,c)+W(a+1,c+1)\\leqslant W(a+1,c)+W(a,c+1)$<div align=\"right\">(1)</div></p>\n<p>$\\therefore\\forall a+1&lt;c,W(a+1,c)+W(a+2,c+1)\\leqslant W(a+2,c)+W(a+1,c+1)$<div align=\"right\">(2)</div></p>\n<p>$(1)$、$(2)$ 式相加：$W(a,c)+W(a+2,c+1)\\leqslant W(a+2,c)+W(a,c+1)$</p>\n<p>进一步地：$\\therefore\\forall a\\leqslant b\\leqslant c,W(a,c)+W(b,c+1)\\leqslant W(b,c)+W(a,c+1)$</p>\n<p>同理：$\\therefore\\forall a\\leqslant b\\leqslant c\\leqslant d,W(a,c)+W(b,d)\\leqslant W(b,c)+W(a,d)$</p>\n<p>证毕。</p>\n<h3 id=\"决策单调性\"><a href=\"#决策单调性\" class=\"headerlink\" title=\"决策单调性\"></a>决策单调性</h3><p>对于一个 $1D&#x2F;1D$ 的转移方程 $f_i&#x3D;f_j+W(i,j)$，函数 $w$ 满足四边形不等式是其满足决策单调性的充分条件证明如下：</p>\n<p>$\\because t_i$ 在 $f_i$ 的决策点中最优</p>\n<p>$\\therefore\\forall i\\in[1,n],j\\in[0,t_i),f_{t_i}+W(t_i,i)\\leqslant f_j+W(j,i)$<div align=\"right\">(3)</div></p>\n<p>又 $\\because\\forall k\\in(i,n],j&lt;t_i&lt;i&lt;k$，且函数 $w$ 满足四边形不等式</p>\n<p>$\\therefore W(j,i)+W(t_i,k)\\leqslant W(j,k)+W(t_i,i)$</p>\n<p>$\\therefore W(t_i,k)-W(t_i,i)\\leqslant W(j,k)-W(j,i)$</p>\n<p>与 $(3)$ 式相加得：$f_{t_i}+W(t_i,k)\\leqslant f_j+W(j,k)$</p>\n<p>也就是说，从任意在 $i$ 的最优决策点 $t_i$ 之前的决策点，转移到 $i$ 后面任意一个决策点都没有从 $t_i$ 转移优。那么对于 $i$ 之后的决策点 $k$，他的最优决策点一定属于 $[t_i,k)$，那么 $t_i$ 不减，决策具有单调性。</p>\n<p>证毕。</p>\n<h2 id=\"证明决策单调性\"><a href=\"#证明决策单调性\" class=\"headerlink\" title=\"证明决策单调性\"></a>证明决策单调性</h2><p>提供三种方法，后两种与前面的<a href=\"#%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F\">思考方式</a>有关。</p>\n<h3 id=\"四边形不等式法\"><a href=\"#四边形不等式法\" class=\"headerlink\" title=\"四边形不等式法\"></a>四边形不等式法</h3><p>本题转移方程形如 $f_i&#x3D;f_j+W(i,j)$，其中 $W(i,j)&#x3D;(w_i-w_j-L-1)^2$，证明如下：</p>\n<p>记 $Q&#x3D;w_i-w_j-L-1$</p>\n<p>$\\therefore W(i,j)&#x3D;Q^2$</p>\n<p>$<br>\\begin{aligned}<br>\\therefore W(i+1,j+1)&amp;&#x3D;(w_{i+1}-w_{j+1}-L-1)^2\\<br>&amp;&#x3D;\\big((s_{i+1}+i+1)-(s_{j+1}+j+1)-L-1\\big)^2\\<br>&amp;&#x3D;\\big((s_i+c_{i+1}+i+1)-(s_j+c_{j+1}+j+1)-L-1\\big)^2\\<br>&amp;&#x3D;\\big((s_i+i)-(s_j+j)-L-1+c_{i+1}-c_{j+1}\\big)^2\\<br>&amp;&#x3D;\\big((w_i-w_j-L-1)+c_{i+1}-c_{j+1}\\big)^2\\<br>&amp;&#x3D;\\big(Q+c_{i+1}-c_{j+1}\\big)^2,<br>\\end{aligned}\\<br>\\begin{aligned}<br>W(i,j+1)&amp;&#x3D;(w_i-w_{j+1}-L-1)^2\\<br>&amp;&#x3D;\\big(w_i-(s_{j+1}+j+1)-L-1\\big)^2\\<br>&amp;&#x3D;\\big(w_i-(s_j+c_{j+1}+j+1)-L-1\\big)^2\\<br>&amp;&#x3D;\\big(w_i-(s_j+j)-L-1-c_{j+1}-1\\big)^2\\<br>&amp;&#x3D;\\big((w_i-w_j-L-1)-c_{j+1}-1\\big)^2\\<br>&amp;&#x3D;\\big(Q-c_{j+1}-1\\big)^2,<br>\\end{aligned}\\<br>\\begin{aligned}<br>W(i+1,j)&amp;&#x3D;(w_{i+1}-w_j-L-1)^2\\<br>&amp;&#x3D;\\big((s_{i+1}+i+1)-w_j-L-1\\big)^2\\<br>&amp;&#x3D;\\big((s_i+c_{i+1}+i+1)-w_j-L-1\\big)^2\\<br>&amp;&#x3D;\\big((s_i+i)-w_j-L-1+c_{i+1}+1\\big)^2\\<br>&amp;&#x3D;\\big((w_i-w_j-L-1)+c_{i+1}+1\\big)^2\\<br>&amp;&#x3D;\\big(Q+c_{i+1}+1\\big)^2<br>\\end{aligned}<br>$</p>\n<p>$<br>\\therefore W(i,j)+W(i+1,j+1)&#x3D;2Q^2+2Qc_{i+1}-2Qc_{j+1}+c_{i+1}^2-2c_{i+1}c_{j+1}+c_{j+1}^2,\\<br>W(i+1,j)+W(i,j+1)&#x3D;2Q^2+2Qc_{i+1}+c_{i+1}^2+2c_{i+1}+2-2Qc_{j+1}+c_{j+1}^2+2c_{j+1}<br>$</p>\n<p>$<br>\\begin{aligned}<br>\\therefore W(i,j)+W(i+1,j+1)-W(i+1,j)-W(i,j+1)&amp;&#x3D;-2-2c_{i+1}-2c_{j+1}-2c_{i+1}c_{j+1}\\<br>&amp;&#x3D;-2(c_{i+1}+1)(c_{j+1}+1)<br>\\end{aligned}<br>$</p>\n<p>又 $\\because c_i,c_j\\geq1$</p>\n<p>$\\therefore-2(c_{i+1}+1)(c_{j+1}+1)\\leqslant-8&lt;0$</p>\n<p>$\\therefore W(i,j)+W(i+1,j+1)\\leqslant W(i+1,j)+W(i,j+1)$</p>\n<p>四边形不等式成立，所以方程具有决策单调性。</p>\n<p>证毕。</p>\n<h3 id=\"数形法\"><a href=\"#数形法\" class=\"headerlink\" title=\"数形法\"></a>数形法</h3><p>由于 $k_0&#x3D;2(w_i-L-1)$ 单增，所以第一个斜率大于 $k_0$ 的线段逐渐往后移，最优决策点后移，即最优决策点的位置单增。</p>\n<p>证毕。</p>\n<h3 id=\"线性规划法\"><a href=\"#线性规划法\" class=\"headerlink\" title=\"线性规划法\"></a>线性规划法</h3><p>由于直线斜率 $2(w_i-L-1)$ 单增，故其与凸包的切点横坐标单增，最优决策点的位置单增。</p>\n<p>证毕。</p>\n<h2 id=\"再实现\"><a href=\"#再实现\" class=\"headerlink\" title=\"再实现\"></a>再实现</h2><p>对于上面的<a href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0\">实现方法</a>，我们只用更改操作1：在第一根线段的斜率小于等于 $k_0$ 时弹出队首，重复直至第一根线段的斜率大于 $k_0$，此时队首即为最优决策点。</p>\n<p>根据决策单调性，后面决策点的最优决策点一定在队首后面，且每个决策点++至多++{.dot}进出队列1次，时间复杂度 $O(n)$。</p>\n<h2 id=\"本题代码\"><a href=\"#本题代码\" class=\"headerlink\" title=\"本题代码\"></a>本题代码</h2><p>基于上面的方法，建议自己实现一遍，再看我的代码。</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\n#define db double\nusing namespace std;\nconst int N=50005;\nint n,L;\ndb c[N],s[N],f[N];\nint head,tail,Q[N];\n\ninline db w(int i)&#123;return s[i]+i;&#125;\ninline db X(int i)&#123;return w(i);&#125;\ninline db Y(int i)&#123;return f[i]+w(i)*w(i);&#125;\ninline db slope(int i,int j)&#123;return (Y(i)-Y(j))/(X(i)-X(j));&#125;\n\nint main()&#123;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;L);\n    for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;c[i]);\n    for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+c[i];\n\n    head=tail=1;\n    //注意此时队列中已经有一个决策点j=0，f[1]需要从这里转移\n    for(int i=1;i&lt;=n;i++)&#123;\n        while(head&lt;tail&amp;&amp;slope(Q[head],Q[head+1])&lt;=2*(w(i)-L-1)) ++head;\n        //寻找最优决策点，并把前面的点弹出。\n        f[i]=f[Q[head]]+(w(i)-w(Q[head])-L-1)*(w(i)-w(Q[head])-L-1);\n        //用最优决策点（即队首）更新f[i]。\n        while(head&lt;tail&amp;&amp;slope(i,Q[tail-1])&lt;=slope(Q[tail-1],Q[tail])) --tail;\n        //把i当作决策点维护凸包，把队尾不符合凸包凸性的决策点弹出。\n        Q[++tail]=i;\n        //把i加入凸包。\n    &#125;\n\n    printf(&quot;%lld\\n&quot;,(long long)f[n]);\n    return 0;\n&#125;\n</code></pre>\n<p>但是一般不建议这样写，除法容易丢精度，所以我们把斜率的除换成交叉相乘：</p>\n<pre><code class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\n#define db double\nusing namespace std;\nconst int N=50005;\nint n,L;\ndb c[N],s[N],f[N];\nint head,tail,Q[N];\ninline db w(int i)&#123;return s[i]+i;&#125;\ninline db X(int i)&#123;return w(i);&#125;\ninline db Y(int i)&#123;return f[i]+w(i)*w(i);&#125;\ninline int chk1(int i,int j,int p)&#123;return Y(j)-Y(i)&lt;=2ll*(w(p)-L-1)*(X(j)-X(i));&#125;\ninline int chk2(int i,int j,int p)&#123;return (Y(p)-Y(i))*(X(j)-X(i))&lt;=(Y(j)-Y(i))*(X(p)-X(i));&#125;\n//要卡常的话可以不写函数，直接写表达式\nint main()&#123;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;L);\n    for(int i=1;i&lt;=n;i++) scanf(&quot;%lf&quot;,&amp;c[i]);\n    for(int i=1;i&lt;=n;i++) s[i]=s[i-1]+c[i];\n    head=tail=1;\n    for(int i=1;i&lt;=n;i++)&#123;\n        while(head&lt;tail&amp;&amp;chk1(Q[head],Q[head+1],i)) ++head;\n        f[i]=f[Q[head]]+(w(i)-w(Q[head])-L-1)*(w(i)-w(Q[head])-L-1);\n        while(head&lt;tail&amp;&amp;chk2(Q[tail-1],Q[tail],i)) --tail;\n        Q[++tail]=i;\n    &#125;\n    printf(&quot;%lld\\n&quot;,(long long)f[n]);\n    return 0;\n&#125;\n</code></pre>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>斜率优化代码一般很短，但是细节较多，简单列举一下：</p>\n<ol>\n<li>尽量不计算斜率，用交叉相乘，防止丢精。</li>\n<li>判断是否需要在队列里插入初始值，如<a href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\">例题</a>。</li>\n<li>一般来说，可以出队的边界情况是 <code>head&lt;tail</code>。</li>\n<li>如 $x_i$ 可能出现相等的情况：如果你使用的是交叉相乘，那你不用额外做什么；如果你计算了斜率，那就要特判一下 <code>x[i]==x[j]?INF:...</code>。</li>\n<li>一定要根据决策的优劣、题目要求的 $min&#x2F;max$ 来判断要维护上凸还是下凸包。</li>\n<li>交叉相乘的时候，尽量把乘出去的 <code>x[j]-x[i]</code> 弄成正数，这样就不用考虑变号的问题了。</li>\n<li>建议比较都用 <code>&lt;=</code> 或 <code>&gt;=</code> 代替 <code>&lt;</code> 或 <code>&gt;</code>，因为斜率相等的点取那个都无所谓，这样还可以去重。</li>\n<li>注意看交叉相乘会不会炸 <code>long long</code>，会的话换 <code>double</code>，输出注意转整型。</li>\n<li>一定要计算斜率的话要用 <code>long double</code>。</li>\n<li>注意 $x_i$ 及斜率的单调性，不满足单调的要使用其他方法，见下文。</li>\n</ol>\n<h1 id=\"不单调斜优\"><a href=\"#不单调斜优\" class=\"headerlink\" title=\"不单调斜优\"></a>不单调斜优</h1><p>不单调，即斜优的某些元素不单调，如下：</p>\n<h2 id=\"斜率不单调\"><a href=\"#斜率不单调\" class=\"headerlink\" title=\"斜率不单调\"></a>斜率不单调</h2><p>亦可解释为最优决策点不单调，就是不能证明决策单调性，此时不能再弹出队首，只能二分。</p>\n<h2 id=\"横坐标不单调\"><a href=\"#横坐标不单调\" class=\"headerlink\" title=\"横坐标不单调\"></a>横坐标不单调</h2><p>此时插入决策点时可能会插在凸包中间，而队列不支持这种操作。</p>\n<p>可以使用平衡树实现插入、查找前驱操作，或着用<a href=\"/OI/cdq/\">CDQ分治</a>提供单调性，具体见下。</p>\n<p>也可使用李超线段树，<del>但是我不会（</del></p>\n<h2 id=\"斜率、横坐标均不单调\"><a href=\"#斜率、横坐标均不单调\" class=\"headerlink\" title=\"斜率、横坐标均不单调\"></a>斜率、横坐标均不单调</h2><p>用平衡树。把 $k_0$ 放到平衡树上找前驱，再更新dp值，最后 <code>insert</code>。</p>\n<p>用 $CDQ$，步骤如下：</p>\n<ol>\n<li>把 $x_i$ 小于 $mid$ 的点作为左区间，其余作为右区间（如果 $x_i$ 单调则原区间的左区间就是左区间，右区间就是右区间）。</li>\n<li>递归左区间。</li>\n<li>对于左区间用单调队列维护出凸包（正确性见下），用它更新右区间。</li>\n<li>递归右区间。</li>\n<li>最后对整个区间对 $x_i$ 排序，此时这个区间 $x_i$ 单调，上一级区间可以直接对于本区间维护凸包，步骤3正确性得证。</li>\n</ol>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><h2 id=\"普通斜优-1\"><a href=\"#普通斜优-1\" class=\"headerlink\" title=\"普通斜优\"></a>普通斜优</h2><p><a href=\"https://www.luogu.com.cn/problem/P2120\">[ZJOI2007] 仓库建设</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3648\">[APIO2014] 序列分割</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P3628\">[APIO2010] 特别行动队</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P4360\">[CEOI2004] 锯木厂选址</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P5017\">[NOIP2018 普及组] 摆渡车</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2900\">[USACO08MAR] Land Acquisition G</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P4072\">[SDOI2016] 征途</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P4056\">[JSOI2009] 火星藏宝图</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P6047\">丝之割</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P5308\">[COCI2018-2019#4] Akvizna</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P1721\">[NOI2016] 国王饮水记</a></p>\n<h2 id=\"不单调斜优-1\"><a href=\"#不单调斜优-1\" class=\"headerlink\" title=\"不单调斜优\"></a>不单调斜优</h2><p><a href=\"https://www.luogu.com.cn/problem/P2365\">任务安排</a> &amp; <a href=\"https://www.luogu.com.cn/problem/P5785\">[SDOI2012] 任务安排</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P4027\">[NOI2007] 货币兑换</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P4655\">[CEOI2017] Building Bridges</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2497\">[SDOI2012] 基站建设</a></p>\n<p><a href=\"https://www.luogu.com.cn/problem/P2305\">[NOI2014] 购票</a></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><ol>\n<li>ChatGPT</li>\n<li><a href=\"https://www.cnblogs.com/Xing-Ling/p/11210179.html\">辰星凌的博客</a></li>\n<li><a href=\"https://oi-wiki.org/dp/opt/slope/\">OI-wiki</a></li>\n<li>其他大佬的博客</li>\n</ol>\n",
            "tags": [
                "OI",
                "算法",
                "DP"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/summarize/2023gdkoi/",
            "url": "https://tiagim.github.io/OI/summarize/2023gdkoi/",
            "title": "2023GDKOI游记",
            "date_published": "2023-03-16T06:46:43.000Z",
            "content_html": "<h1 id=\"考前\"><a href=\"#考前\" class=\"headerlink\" title=\"考前\"></a>考前</h1><p>试机的时候搞错机器了，导致没换键盘（那个键盘斜着按不下去），vscode也没配好，直接用的虚拟机的vscode。</p>\n<h1 id=\"Day1\"><a href=\"#Day1\" class=\"headerlink\" title=\"Day1\"></a>Day1</h1><p>顺序开题。</p>\n<p>T1本来写了个结构体包装的矩乘（觉得这样比较方便），但是莫名RE调了20min，后来改成函数乘，就对了。以为随机取点正确率不高，又没做过矩阵乘向量的题，所以只拿了暴力分。</p>\n<p>考后发现随机取点能A。。。</p>\n<p>写T2的时候忘了错排公式，推了好久没推出来。我以为有式子，于是推了30min，还没推出来，也没想到别的做法，我好蠢。</p>\n<p>T3完全不会。</p>\n<h1 id=\"Day2\"><a href=\"#Day2\" class=\"headerlink\" title=\"Day2\"></a>Day2</h1><p>顺序开题。</p>\n<p>T1写大分讨，寄了，没想到cdq，只过了链。</p>\n<p>T2、T3不会。</p>\n<hr>\n<p>还是写什么挂什么，代码能力不够，学的东西不会用。</p>\n",
            "tags": [
                "OI",
                "游记",
                "其他"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/summarize/2023spring/",
            "url": "https://tiagim.github.io/OI/summarize/2023spring/",
            "title": "2023春测游记",
            "date_published": "2023-03-16T02:23:45.000Z",
            "content_html": "<h1 id=\"Step0\"><a href=\"#Step0\" class=\"headerlink\" title=\"Step0\"></a>Step0</h1><p>考前本来想看点什么的，但是看的也没用到。</p>\n<h1 id=\"Step1\"><a href=\"#Step1\" class=\"headerlink\" title=\"Step1\"></a>Step1</h1><p>开考后先全看一遍，再写完T1。之前考过类似T1的题，但是比它难多了。不过我比较蠢，一开始还在想怎么那数据结构维护这个东西（之前那题就是这样），然后意识到这是大水题（</p>\n<p>总共花了10min。</p>\n<h1 id=\"Step2\"><a href=\"#Step2\" class=\"headerlink\" title=\"Step2\"></a>Step2</h1><p>然后看T2。</p>\n<p>先想到一个二分 $b$ 的做法，但是写挂了，调了30min没调出来。然后换了一种思路，写分块+二分+map去重，还是挂了。</p>\n<h1 id=\"Step3\"><a href=\"#Step3\" class=\"headerlink\" title=\"Step3\"></a>Step3</h1><p>再写T3。</p>\n<p>想到一个 $O(n^2)$ dp做法，写了3k发现假了。然后大部分时间就花在搞T2和T3了。</p>\n<p>T4不会。</p>\n<h1 id=\"StepEnd\"><a href=\"#StepEnd\" class=\"headerlink\" title=\"StepEnd\"></a>StepEnd</h1><p>这次顺序开题，在T2就卡了，好像写什么什么挂。</p>\n<p>对于各种技巧和算法不熟练，思路不缜密，分析不到位（这些问题好像经常有？还在改进）。</p>\n",
            "tags": [
                "OI",
                "游记",
                "其他"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/dfz/",
            "url": "https://tiagim.github.io/OI/dfz/",
            "title": "点分治",
            "date_published": "2022-12-07T14:17:27.000Z",
            "content_html": "<p>暂未填坑。</p>\n<span id=\"more\"></span>\n",
            "tags": [
                "OI",
                "算法"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/cdq/",
            "url": "https://tiagim.github.io/OI/cdq/",
            "title": "CDQ分治",
            "date_published": "2022-12-07T14:15:53.000Z",
            "content_html": "<p>暂未填坑。</p>\n<span id=\"more\"></span>\n",
            "tags": [
                "OI",
                "算法"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/faster/",
            "url": "https://tiagim.github.io/OI/faster/",
            "title": "常数优化",
            "date_published": "2022-12-04T12:19:36.000Z",
            "content_html": "<blockquote>\n<p>先看$c++$版本以及是否打开优化开关</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<ul>\n<li>快读快写（见文末）</li>\n<li>频繁改变的变量加<strong>register</strong></li>\n<li>访问<code>a[i]</code>后访问<code>a[i+1]</code>、<code>a[i+2]</code>···</li>\n<li>数组开奇数（原因不明）</li>\n<li>循环展开：<code>for(int i=1;i&lt;=10000;i++)a[i]++;</code> $\\Rightarrow$ <code>for(int i=1;i&lt;=10000;i+=4)a[i]++,a[i+1]++,a[i+2]++,a[i+3]++;</code></li>\n<li>位运算：<ul>\n<li><code>x*=(2,4,8,16...)</code> $\\Rightarrow$ <code>x&lt;&lt;=(1,2,3,4...)</code> ( <code>/=</code> $\\Rightarrow$ <code>&gt;&gt;=</code> )</li>\n<li><code>x%2</code> $\\Rightarrow$ <code>x&amp;1</code></li>\n<li><code>x&gt;y</code> $\\Rightarrow$ <strong>int</strong>: <code>y-x&gt;&gt;31</code> <strong>long long</strong>: <code>y-x&gt;&gt;63</code></li>\n<li><code>-x</code> $\\Rightarrow$ <code>~x+1</code></li>\n<li><code>swap(x,y)</code> $\\Rightarrow$ <code>x^=y^=x^=y</code></li>\n<li><code>abs(x)</code> $\\Rightarrow$ <code>(x^(x&gt;&gt;31))-(x&gt;&gt;31)</code> <strong>long long</strong>: <code>31</code> $\\Rightarrow$ <code>63</code></li>\n</ul>\n</li>\n<li><strong>bool</strong> $\\Rightarrow$ <strong>int&#x2F;bitset</strong></li>\n<li><strong>inline</strong></li>\n<li><code>if(a)b;else c;</code> $\\Rightarrow$ <code>a?b:c;</code></li>\n<li><code>if(a)b;</code> $\\Rightarrow$ <code>a&amp;&amp;b;</code></li>\n<li><code>;</code> $\\Rightarrow$ <code>,</code></li>\n<li><code>int i=1;</code> $\\Rightarrow$ <code>int i(1);</code></li>\n<li><code>i++;</code> $\\Rightarrow$ <code>++i;</code></li>\n</ul>\n<pre><code class=\"language-cpp\">namespace io &#123;\n    const int __SIZE = (1 &lt;&lt; 21) + 1;\n    char ibuf[__SIZE], *iS, *iT, obuf[__SIZE], *oS = obuf, *oT = oS + __SIZE - 1, __c, qu[55]; int __f, qr, _eof;\n    #define Gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, __SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n    inline void flush () &#123; fwrite (obuf, 1, oS - obuf, stdout), oS = obuf; &#125;\n    inline void gc (char &amp;x) &#123; x = Gc(); &#125;\n    inline void pc (char x) &#123; *oS ++ = x; if (oS == oT) flush (); &#125;\n    inline void pstr (const char *s) &#123; int __len = strlen(s); for (__f = 0; __f &lt; __len; ++__f) pc (s[__f]); &#125;\n    inline void gstr (char *s) &#123; for(__c = Gc(); __c &lt; 32 || __c &gt; 126 || __c == &#39; &#39;;)  __c = Gc();\n        for(; __c &gt; 31 &amp;&amp; __c &lt; 127 &amp;&amp; __c != &#39; &#39; &amp;&amp; __c != &#39;\\n&#39; &amp;&amp; __c != &#39;\\r&#39;; ++s, __c = Gc()) *s = __c; *s = 0; &#125;\n    template &lt;class I&gt; inline bool gi (I &amp;x) &#123; _eof = 0;\n        for (__f = 1, __c = Gc(); (__c &lt; &#39;0&#39; || __c &gt; &#39;9&#39;) &amp;&amp; !_eof; __c = Gc()) &#123; if (__c == &#39;-&#39;) __f = -1; _eof |= __c == EOF; &#125;\n        for (x = 0; __c &lt;= &#39;9&#39; &amp;&amp; __c &gt;= &#39;0&#39; &amp;&amp; !_eof; __c = Gc()) x = x * 10 + (__c &amp; 15), _eof |= __c == EOF; x *= __f; return !_eof; &#125;\n    template &lt;typename I,typename ...Args&gt; inline bool gi(I &amp;tmp, Args &amp;...tmps) &#123; return gi(tmp) ? gi(tmps...), 1 : 0; &#125;\n    template &lt;class I&gt; inline void print (I x) &#123; if (!x) pc (&#39;0&#39;); if (x &lt; 0) pc (&#39;-&#39;), x = -x;\n        while (x) qu[++ qr] = x % 10 + &#39;0&#39;,  x /= 10; while (qr) pc (qu[qr --]); &#125;\n    template &lt;class I&gt; inline void write(char _c,  I x) &#123; print(x), pc(_c); &#125;\n    template &lt;typename I,typename ...Args&gt; inline void write(char __enc, I tmp, Args ...tmps) &#123; write(__enc, tmp), write(__enc, tmps...); &#125;\n    struct Flusher_ &#123;~Flusher_()&#123;flush();&#125;&#125;io_flusher_;\n&#125; using io::pc; using io::gc; using io::pstr; using io::gstr; using io::gi; using io::write; using io::print;\n</code></pre>\n<p>用法：</p>\n<ol>\n<li><p>使用 <code>gi(x, ...);</code> 读入任意多个任意的整型 <code>x</code> 等价于 <code>scanf(&quot;%d...&quot;, &amp;x, ...);</code>其中可以将 <code>%d</code> 自动识别为对应类型。</p>\n</li>\n<li><p>使用 <code>print(x);</code> 输出一个任意的整型 <code>x</code> 等价于 <code>printf(&quot;%d&quot;, x);</code>其中可以将 <code>%d</code> 自动识别为对应类型。</p>\n</li>\n<li><p>使用 <code>write(c, x, ...);</code> 输出任意多个任意的整型 <code>x</code> 并以 <code>c</code> 为分隔符，等价于 <code>printf(&quot;%d%c...&quot;, x, c, ...);</code>其中可以将 <code>%d</code> 自动识别为对应类型。</p>\n</li>\n<li><p>使用 <code>gc(c);</code> 读入一个字符 <code>c</code> 等价于 <code>scanf(&quot;%c&quot;, &amp;c)</code></p>\n</li>\n<li><p>使用 <code>pc(c);</code> 输出一个字符 <code>c</code> 等价于 <code>putchar(c);</code></p>\n</li>\n<li><p>使用 <code>gstr(str);</code> 读入一个字符串 <code>str</code> 等价于 <code>scanf(&quot;%s&quot;, str);</code> 可以用 <code>gstr(str + 1);</code> 替换 <code>scanf(&quot;%s&quot;, str + 1);</code></p>\n</li>\n<li><p>使用 <code>pstr(str);</code> 输出一个字符串 <code>str</code> 等价于 <code>printf(&quot;%s&quot;, str);</code></p>\n</li>\n</ol>\n",
            "tags": [
                "OI",
                "其他"
            ]
        },
        {
            "id": "https://tiagim.github.io/OI/summarize/2022noip/",
            "url": "https://tiagim.github.io/OI/summarize/2022noip/",
            "title": "2022NOIP游记",
            "date_published": "2022-12-01T14:50:52.000Z",
            "content_html": "<p>今年考得比较离谱。</p>\n<span id=\"more\"></span>\n<p>先开的T1。T1想到朴素暴力：处理出纵向和横向连续的“0”，再按“c”拼接，“f”往下延申。T1想到这里就没有进展了，一直没想到用前缀和，因为我太菜了。实际上换一种思考方式还是很容易想到前缀和的，然而我没有，还是因为我太菜了。T1浪费了2h+，出来听说其他人火速切T1，挺无语的。</p>\n<p>T2不会。</p>\n<p>后30min，T3打了一个复杂度极高的暴力，还挂了。</p>\n<p>最后5min，T4打了st表，没时间测大样例。</p>\n<p>以后还是多练练。希望wc能有所进步吧。</p>\n",
            "tags": [
                "OI",
                "游记",
                "其他"
            ]
        }
    ]
}